#define ENC_A 34  // Encoder canal A (verde)

volatile long encoderCount = 0;

// Ajusta segÃºn tu encoder
const int pulsesPerRevolution = 30;  // CAMBIA este valor si ya sabes el real

// Tiempo de mediciÃ³n en segundos
const int tiempoMedicion = 10;

void IRAM_ATTR encoderISR() {
  encoderCount++;
}

void setup() {
  Serial.begin(115200);
  delay(1000); // Espera a que abra bien el monitor serial

  pinMode(ENC_A, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENC_A), encoderISR, RISING);

  Serial.println("ðŸŸ¢ MediciÃ³n de RPM manual");
  Serial.println("ðŸ‘‰ Gira el eje del motor durante 10 segundos.");
  delay(3000);

  encoderCount = 0; // Reinicia el conteo

  unsigned long startTime = millis();
  unsigned long endTime = startTime + (tiempoMedicion * 1000);

  while (millis() < endTime) {
    // Esperando durante los 10 segundos
  }

  detachInterrupt(digitalPinToInterrupt(ENC_A)); // Detenemos la interrupciÃ³n

  // CÃ¡lculo de RPM
  long pulsos = encoderCount;
  float vueltas = (float)pulsos / pulsesPerRevolution;
  float rpm = vueltas * (60.0 / tiempoMedicion);

  Serial.println("âœ… MediciÃ³n completada.");
  Serial.print("ðŸ”„ Pulsos detectados: ");
  Serial.println(pulsos);
  Serial.print("ðŸ” Vueltas detectadas: ");
  Serial.println(vueltas);
  Serial.print("ðŸ“ˆ RPM estimadas: ");
  Serial.println(rpm);
}

void loop() {
  // No hace nada despuÃ©s
}
